In this section, we propose a novel algorithm for online enumeration of all MIVCs. The algorithm is built out of two basic procedures: shrink and grow. The grow procedure is symmetric to the shrink one, i.e., given an inadequate set for $(I, T) \vdash P$, the grow procedure finds a maximal inadequate set for $(I, T) \vdash P$. In the following, we first closely describe how these two procedures work, and then we propose a way to combine them to form an efficient online MIVC enumeration algorithm. 

%In our algorithm we maintain the sets \textit{Explored} and  \textit{Unexplored}. Every time a set $U$ of conjuncts is determined to be adequate, the set $U$ as well as all its supersets are moved to the set  \textit{Explored} as due to the monotonicity they are all adequate. Symmetrically for an inadequate set of conjuncts and the set \textit{Unexplored}.

\subsection{Shrink Procedure}

We can effectively use the set  \textit{Explored} for speeding up the shrinking procedure. When testing the set $U \setminus \{T_i\}$ (see line 2 in Algorithm~\ref{shrin-procedure}) we first check whether  $U \setminus \{T_i\}$ is explored. If so, the status of  $U \setminus \{T_i\}$ is known and no test for adequacy is needed.

However, there is one more observation that can be exploited.


\begin{observation}
\label{observation:explored-property}
Let $U_1, U_2$ be subsets of $T$ such that $U_1$ is explored, $U_2$ is unexplored, and $U_1 \subset U_2$. Then $U_1$ is inadequate  for $(I, T) \vdash P$ .\\
Symetrically, if $U_1, U_2$ are subsets of $T$ such that $U_2$ is explored, $U_1$ is unexplored, and $U_1 \subset U_2$. Then $U_2$ is adequate  for $(I, T) \vdash P$ .
\end{observation}

\begin{proof}
If $U_1$ is adequate, then all of its supersets are necessarily adequate. Thus, if $U_1$ is determined to be adequate, then not just $U_1$ but also all of its supersets becomes explored. Since $U_1$ is explored and $U_2$ is unexplored, then $U_1$ is necessarily an inadequate subset of $T$.
\end{proof}

In other words, we are quaranteed that whenever during the shrinking procedure we come across an explored set, this set is inadequate. Therefore as a further optimization in our algorithm we try to identify as many inadequate sets as possible before starting the shrinking procedure. The search for inadequate sets is done with the help  of grow procedure.






\subsection{Grow Procedure}
\begin{algorithm}[!t]
\label{alg:approx-grow}
\input{./algs/alg_grow_approximation}
\caption{Approximate grow}
\end{algorithm}

Recall that if a set is determined to be inadequate then all of its subsets are necessarily also inadequate. Therefore, the larger set is determined to be inadequate, the more inadequate sets become explored.  %(due to the monotonicity of adequacy).
To identify inadequate sets as quickly as possible we search for maximal inadequate sets (MISes).

In order to find a MIS, we can find an inadequate set $U \subset T$ and use a process called \emph{grow} which turns $U$ to a MIS for $(I,T) \vdash P$.
Grow procedure iteratively attempts to add elements from $T \setminus U$ to $U$, checking each new set for adequacy and keeping only changes that leave the set inadequate. Same as in the case of shrink procedure, we can use the set $Explored$ to avoid checking sets whose status is already known.
However, such grow procedure might still perform too many checks for adequacy and thus be very inefficient.


Instead, we propose to use a different approach. Algorithm~\ref{alg:approx-grow} shows a procedure that, given an inadequate set $U$ for $(I, T) \vdash P$, finds an \emph{approximately} maximal inadequate set.
It first finds some maximal unexplored set $M$ such that $M \supseteq U$ and checks it for adequacy.
If $M$ is inadequate, then it is necessarily a MIS
(this is a straightforward consequence of Observation~\ref{observation:explored-property}).
Otherwise, if $M$ is adequate then it is iteratively reduced until an inadequate set is found.
In particular, whenever $M$ is found to be adequate, the approximative procedure \texttt{IVC\_UC} by Ghassabani et al.~\cite{single-mivc} is used to find an approximate MIVC $M_{IVC}$ of $M$ which succinctly explains $M$'s adequacy. In order to turn $M$ into an inadequate set, it is reduced by one element from $M_{IVC} \setminus U$ and checked for adequacy. If $M$ is still adequate then the approximate growing procedure continues with a next iteration. Otherwise, if $M$ is inadequate, the procedure finishes.

\begin{proposition}
Given an unexplored inadequate set $U$ for $(I,T) \vdash P$ and a set $\mathit{Unexplored}$ of unexplored subsets of $T$, Algorithm~\ref{alg:approx-grow} returns an \emph{unexplored} inadequate subset $M$ of $T$.
\end{proposition}

\begin{proof}
Let us denote initial $M$ as $M_{init}$. Since $M_{init} \supseteq U$ and $M$ is recursively reduced only by elements that are not contained in $U$, then in every iteration holds that $U \subseteq M \subseteq M_{init}$. Since both $U, \, M_{init}$ are unexplored, then $M$ is necessarily also unexplored.
\end{proof}

\todo{JB: Perhaps give a simple running example.}


\subsection{Complete Algorithm}
In this section, we describe, how to combine the shrink and grow methods in order to form an efficient online MIVC enumeration algorithm.

Since knowledge of (approximately) maximal inadequate subsets might be used to speed up shrinking procedures, it might be tempting to first find all maximal inadequate subsets. However, there can be up to exponentially many such subsets with respect to the size of $T$. Thus, finding first all maximal inadequate subsets is in general intractable. Instead, we propose to alternate both shrinking and growing procedures. Note, that during shrinking, we might determine some subsets to be inadequate, and such subsets can be subsequently used as \emph{seeds} for growing. Dually, we might determine some subsets to be adequate during growing, and such subsets can be used as \emph{seeds} for shrinking procedure. Thus, both these procedures somehow complements each other.

The pseudocode of our algorithm is shown in Algorithm~\ref{alg:allmivc}. The computation of the algorithm starts with an initialisation procedure \texttt{Init} which creates a global variable $\mathit{Unexplored}$ for maintaining the unexplored subsets and a global shrinking queue $\mathit{shrinkingQueue}$ for storing seeds for the shrinking procedure. Then the main procedure \texttt{FindMIVCs} of our algorithm is called. 

Procedure \texttt{FindMIVCs} works iteratively. In each iteration, the procedure picks a maximal unexplored subset $U_{max}$ and checks it for adequacy. If $U_{max}$ is inadequate, then it and all of its subsets are marked as explored. Otherwise, if $U_{max}$ is adequate, then the procedure \texttt{IVC\_UC} turns it into an approximately minimal IVC, and subsequently the procedure \texttt{Shrink} shrinks it into a MIVC.

Procedure \texttt{Shrink} works as described in Section~\ref{sec:shrink}. However, besides shrinking the given set into a MIVC, the procedure has also side effect. Every inadequate set that is found during the shrinking is stored in a queue $\mathit{growingQueue}$. At the end of the procedure, all of these inadequate sets are grown into approximately maximal inadequate sets using the procedure \texttt{Grow}.

Procedure \texttt{Grow} turns a given inadequate set $V$ into an approximately maximal inadequate set $M$ as described in Section~\ref{sec:grow}. The resultant set and all of its subsets are marked as explored. Moreover, every adequate set that is found during the growing is marked as explored and enqueued into $\mathit{shrinkingQueue}$. 
The queue $\mathit{shrinkingQueue}$ is dequeued at the end of each iteration of the main procedure \texttt{FindMIVCs}.  \todo{JB: describe how we deal with explored subsets (seeds) in the queue}.



\todo{correctness}

\begin{algorithm}[!t]
\input{./algs/alg}
\caption{AllMIVC algorithm}
\label{alg:allmivc}
\end{algorithm}




