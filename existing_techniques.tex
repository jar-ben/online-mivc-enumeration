\newcommand{\fUnex}{f_{\mathit{Unexplored}}}
Let us first recall 
%Consider first 
a naive enumeration algorithm that   explicitly checks each subset of $T$ for being an IVC  and then finds the minimal IVCs  using subset inclusion relation. The main disadvantage of this approach is the   exponential number of subsets of $T$.
We briefly describe existing techniques that can be used to find all MIVCs while checking only a a small portion of subsets of $T$  for being IVCs.  An elaborated algorithm was     very recently presented by Ghassabani et al.~\cite{}. However,  most of the techniques were inspired by the MUS enumeration techniques~\cite{} previously proposed in the area of constraint processing. 



\begin{definition}[Inadequacy] A set of conjuncts  $U \subseteq T$  is an \emph{inadequate} set for $(I, T) \vdash P$ iff $(I, U) \nvdash P$. Especially, $U \subseteq T$ is a \emph{Maximal Inadequate Subset (MIS)} for $(I, T) \vdash P$ iff $U$ is inadequate and $\forall T_i \in (T \setminus U): \, (I, U \cup \{ T_i\}) \vdash P$.
\end{definition}

Note that inadequate subsets are duals to inductive validity cores. Each $U \subseteq T$ is either inadequate subset or an inductive validity core. In order to unify the notation, we   use notation \emph{inadequate} and \emph{adequate}. Note that especially minimal inductive validity cores can be thus called  minimal adequate subsets.  



The first property used to improve the naive enumeration algorithm is the \emph{monotonicity} of  adequacy   with respect to the subset inclusion.

\begin{lemma}[Monotonicity]
\label{lemma:monotonicity}
If a set of conjuncts  $U \subseteq T$  is an adequate set for $(I, T) \vdash P$   than all its supersets are adequate for  $(I, T) \vdash P$ as well:
\begin{center}
$\forall U_1 \subseteq U_2 \subseteq T: \, (I, U_1) \vdash P \Rightarrow (I, U_2) \vdash P$.
\end{center}
Symmetrically, if   $U \subseteq T$  is an inadequate set for $(I, T) \vdash P$   than all its subsets are inadequate for  $(I, T) \vdash P$ as well:
\begin{center}
$\forall U_1 \subseteq U_2 \subseteq T: \, (I, U_2) \nvdash P \Rightarrow (I, U_1) \nvdash P$.
\end{center}
\end{lemma}

\begin{proof}
%From $U_1 \subseteq U_2$ we have $U_2 \Rightarrow U_1$. Thus the
If $U_1 \subseteq U_2$ then reachable states of $(I, U_2)$ form  a subset of the reachable states
of $(I, U_1)$.
\end{proof}
%
%\begin{corollary}
%For $(I, T) \vdash P$, if $U \subseteq T$ is inadequate for property $P$, than all of its subsets are inadequate for $P$ as well:
%\begin{center}
%$\forall U_1 \subseteq U_2 \subseteq T: \, (I, U_2) \nvdash P \Rightarrow (I, U_1) \nvdash P$.
%\end{center}
%\end{corollary}


Monotonicity allows  to determine status  of multiple subsets of $T$ while using only a single check for adequacy. For example, if a set $U \subseteq T$ is found to be adequate, than all of its supersets are   adequate and do not need to be explicitly checked. Let     $\mathit{Sup}(U)$ and $\mathit{Sub}(U)$ denote the set of all supersets and subsets of $U$, respectively.

Every algorithm for computing MIVCs has to determine status (i.e adeqaute or inadeguate) of every subset of $T$.  In order to distinguish the subsets whose status is already known from those whose status is not known yet, we denote the former subsets as \emph{explored} subsets and the latter as \emph{unexplored} subsets. Moreover, we distinguish \emph{maximal} resp. \emph{minimal} unexplored subsets 
\begin{itemize}
	\item $U_{max}$ is a \emph{maximal unexplored subset} of $T$ iff $U_{max} \subseteq T$, $U_{max}$ is unexplored, and each of its proper supersets is explored.
	\item $U_{min}$ is a \emph{minimal unexplored subset} of $T$ iff $U_{min} \subseteq T$, $U_{max}$ is unexplored, and each of its proper subsets is explored.
\end{itemize}


%... musime si nejak pamatovat, ty, u kterych vime adequacy, a ty, u kterych ji jeste nevime.
%... explicitni enumerace nemozna. \\
%
%Symbolic representation is based on a well known isomorphism between finite power sets and Boolean algebras. We encode $T = \{T_1, T_2, \ldots , T_n \}$ by using a set of Boolean variables $X = \{x_1, x_2, \ldots , x_n \}$. Each valuation of $X$ then corresponds to a subset of $T$. This allows us to represent the set of unexplored subsets $\mathit{Unexplored}$ using a Boolean formula $\fUnex$ such that each model of $\fUnex$ corresponds to an element of $\mathit{Unexplored}$.
%
%\begin{itemize}
%\item Initially $fUnex$ is $\top$ since all of $\mathcal{P}(T)$ are unexplored. 
%\item When an unexplored subset $U$ is determined to be adequate, then all of its supersets are also determined to be adequate and thus, all become explored. In order to store this information, we add to $\fUnex$ one clause, 
%	$$\fUnex \gets \fUnex \ \wedge  \ \bigvee\limits_{i: T_i \in U} \neg x_i\ .$$
%\item Dually, when $V$ is determined to be inadequate, then all of its supersets are also determined to be adequate and thus, all become explored. In this case, we add to  $\fUnex$ one clause,
%	$$\fUnex \gets \fUnex \ \wedge \  \bigvee\limits_{i: c_i \not\in V} x_i\ .$$
%\end{itemize}
%
%
%\begin{example}\label{ex:unex}
%Let us illustrate the symbolic representation on $T = \{ T_1, T_2, T_3 \}$. If  all subsets of $T$ are unexplored then $\fUnex = \top$. If   $\{T_1, c_T \}$ is determined to be adequate and $\{T_1, T_2 \}$ to be inadequate, then $\fUnex$ is updated to $(\neg x_1 \vee \neg x_3) \wedge (x_3)$.
%\end{example}
%
%In order to get an unexplored subset, we can ask a SAT solver for a model of $\fUnex$. 

\begin{algorithm}[!t]
\label{alg:shrink_bf}
\input{./algs/ivc_bf}
\caption{IVC\_BF: An implementation of the shrinking procedure by Ghassabani et al.~\cite{single-ivc}. }
\end{algorithm}


A straightforward way to find a (so far unexplored) MIVC of $T$ is to find an unexplored adequate subset $U \subseteq T$ and turn $U$  into an MIVC by a process called \emph{shrinking}. Algorithm~\ref{alg:shrink_bf} shows an implementation of the shrinking procedure proposed by Ghassabani et al.~\cite{single-ivc}.
It iteratively attempts to remove elements from the set that is being
shrunk, checking each new set for adequacy and keeping only changes that
leave the set adequate.

%
%  and use a single MIVC extraction algorithm to find an MIVC of $U$ (which is necessarily also  a MIVC of $T$). We call such process of turning $U$ into an MIVC as \emph{shrinking} $U$. Algorithm~\ref{alg:ivc_bf} shows a pseudocode of the single MIVC extraction algorithm called \texttt{IVC\_BF} which was recently presented by Ghassabani et al~\cite{single-ivc}.   
%It iteratively attempts to remove elements from the set that is being
%shrunk, checking each new set for adequacy and keeping only changes that
%leave the set adequate.

%Ghassabani et al. present   algorithm for finding all MIVCs, called \texttt{All\_IVCs}, which is based on the monotonicity property and the shrinking procedure. To obtain each single MIVC, the  algorithm  finds a maximal unexplored subset, checks it for adequacy and if it is adequate, shrinks the set into a MIVC. (using the agorithm \texttt{IVC\_BF}). During the whole computation, the set of unexplored subsets is appropriately maintained. 
This algorithm computes MIVCs in an online manner, however, authors of the algorithm found out that it is rather inefficient since the  shrinking procedure is very expensive. Therefore, they propose to use  algorithm~\cite{single-ivc}, called IVC\_UC, which finds an approximately minimal IVC (i.e. IVC which is not necessarilly minimal)  instead of using the shrinking procedure which returns guaranteed MIVCs. The algorithm IVC\_UC does not output MIVCs in an online manner. Instead, it identifies MIVCs (using subset relation) at the end of the computation when status of all subsets is determined. Their experimental evaluation shows, that IVC\_UC is much faster than IVC\_BF. However, it lacks the ability of online enumeration and it is not applicable in cases, where the complete enumeration is not possible due to the large size of a search space. 

\todo{Pseudocode of \texttt{All\_IVCs}}


\begin{algorithm}[!t]
\label{alg:all_ivcs}
\input{./algs/all_ivcs}
\caption{All\_IVCs: Algorithm for MIVC enumeration by Ghassabani et al.~\cite{all-ivcs}. }
\end{algorithm}


