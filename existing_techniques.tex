\newcommand{\fUnex}{f_{\mathit{Unexplored}}}


Consider
first a naive enumeration algorithm that would explicitly check each subset of $T$ for being IVC,
form the set of all IVCs, and then choose the minimal IVCs from this set (using subset inclusion relation). The main disadvantage of this approach
is the large number of adequacy checks - there are exponentially many subsets of $T$. In this section we briefly describe existing techniques that can be used to find all MIVCs while checking only a small porting of $\mathcal{P}(T)$ for being IVCs. The concept of MIVCs was originally presented very recently by Ghassabani et al.~\cite{}, so all the techniques presented in this section comes from the work by these authors. However, note that most of these techniques were inspired by the MUS enumeration techniques~\cite{} previously proposed in the are of constraint processing. 



\begin{definition}[Inadequacy] $U \subseteq T$ for $(I, T) \vdash P$ is an \emph{inadequate} set iff $(I, U) \nvdash P$. Especially, $U \subseteq T$ is a \emph{Maximal Inadequate Subset (MIS)} for $(I, T) \vdash P$ iff $U$ is inadequate and $\forall T_i \in (T \setminus U): \, (I, U \cup \{ T_i\}) \vdash P$.
\end{definition}

Note that inadequate subsets are duals to inductive validity cores. Each $U \subset T$ is either inadequate subset or an inductive validity core. In order to unify the notation, we will denote individual subsets as either \emph{inadequate} or \emph{adequate}. Note that especially minimal inductive validity cores can be thus called also as minimal adequate subsets.  



The first improvement that can be made to the naive brute-force algorithm is based on the fact, that the adequacy is \emph{monotone} with respect to the subset inclusion: 

\begin{lemma}[Monotonicity]
\label{lemma:monotonicity}
For $(I, T) \vdash P$, if $U \subseteq T$ is adequate for property $P$, than all of its supersets are adequate for $P$ as well:
\begin{center}
$\forall U_1 \subseteq U_2 \subseteq T: \, (I, U_1) \vdash P \Rightarrow (I, U_2) \vdash P$.
\end{center}
\end{lemma}

\begin{proof}
From $U_1 \subseteq U_2$ we have $U_2 \Rightarrow U_1$. Thus the
reachable states of $(I, U_2)$ are a subset of the reachable states
of $(I, U_1)$.
\end{proof}

\begin{corollary}
For $(I, T) \vdash P$, if $U \subseteq T$ is inadequate for property $P$, than all of its subsets are inadequate for $P$ as well:
\begin{center}
$\forall U_1 \subseteq U_2 \subseteq T: \, (I, U_2) \nvdash P \Rightarrow (I, U_1) \nvdash P$.
\end{center}
\end{corollary}

Lemma~\ref{lemma:monotonicity} allows us to determine an adequacy of multiple subsets of $T$ while using only a single check for adequacy. For example, if a set $U \subseteq T$ is found to be adequate, than all of its supersets are necessarily also adequate and do not need to be explicitly considered. Let us by $\mathit{Sup}(U)$ denote the set of all supersets of $U$, and dually by $\mathit{Sub}(U)$ denote the set of all subsets of $U$.

Every algorithm for finding MIVCs, w.r.t. to our problem formulation, starts with zero knowledge of adequacy of individual subsets and ends with a full knowledge of adequacy of individual subsets since the set of all MIVCs implicitly encodes set of all inadequate subsets. 
In order to distinguish the subsets whose adequacy is already known from the subsets whose adequacy is not known yet, we denote the former subsets as \emph{explored} subsets and the latter as \emph{unexplored} subsets. Moreover, let us denote unexplored subsets as \emph{maximal} resp. \emph{minimal} as follows:

\begin{itemize}
	\item $U_{max}$ is a \emph{maximal unexplored subset} of $T$ iff $U_{max} \subseteq T$, $U_{max}$ is unexplored, and each of its proper supersets is explored.
	\item $U_{min}$ is a \emph{minimal unexplored subset} of $T$ iff $U_{min} \subseteq T$, $U_{max}$ is unexplored, and each of its proper subsets is explored.
\end{itemize}


%... musime si nejak pamatovat, ty, u kterych vime adequacy, a ty, u kterych ji jeste nevime.
%... explicitni enumerace nemozna. \\
%
%Symbolic representation is based on a well known isomorphism between finite power sets and Boolean algebras. We encode $T = \{T_1, T_2, \ldots , T_n \}$ by using a set of Boolean variables $X = \{x_1, x_2, \ldots , x_n \}$. Each valuation of $X$ then corresponds to a subset of $T$. This allows us to represent the set of unexplored subsets $\mathit{Unexplored}$ using a Boolean formula $\fUnex$ such that each model of $\fUnex$ corresponds to an element of $\mathit{Unexplored}$.
%
%\begin{itemize}
%\item Initially $fUnex$ is $\top$ since all of $\mathcal{P}(T)$ are unexplored. 
%\item When an unexplored subset $U$ is determined to be adequate, then all of its supersets are also determined to be adequate and thus, all become explored. In order to store this information, we add to $\fUnex$ one clause, 
%	$$\fUnex \gets \fUnex \ \wedge  \ \bigvee\limits_{i: T_i \in U} \neg x_i\ .$$
%\item Dually, when $V$ is determined to be inadequate, then all of its supersets are also determined to be adequate and thus, all become explored. In this case, we add to  $\fUnex$ one clause,
%	$$\fUnex \gets \fUnex \ \wedge \  \bigvee\limits_{i: c_i \not\in V} x_i\ .$$
%\end{itemize}
%
%
%\begin{example}\label{ex:unex}
%Let us illustrate the symbolic representation on $T = \{ T_1, T_2, T_3 \}$. If  all subsets of $T$ are unexplored then $\fUnex = \top$. If   $\{T_1, c_T \}$ is determined to be adequate and $\{T_1, T_2 \}$ to be inadequate, then $\fUnex$ is updated to $(\neg x_1 \vee \neg x_3) \wedge (x_3)$.
%\end{example}
%
%In order to get an unexplored subset, we can ask a SAT solver for a model of $\fUnex$. 

\begin{algorithm}[!t]
\input{./algs/ivc_bf}
\caption{IVC\_BF: Brute force algorithm for computing an MIVC. }
\end{algorithm}


A straightforward way to find an (so far unexplored) MIVC of $T$ is to find an unexplored adequate subset $U \subseteq T$  and use a single MIVC extraction algorithm to find an MIVC of $U$ (which is necessarily also  a MIVC of $T$). We call such process of turning $U$ into an MIVC as \emph{shrinking} $U$. Algorithm~\ref{alg:ivc_bf} shows a pseudocode of the single MIVC extraction algorithm called \texttt{IVC\_BF} which was recently presented by Ghassabani et al~\cite{single-ivc}.   
It iteratively attempts to remove elements from the set that is being
shrunk, checking each new set for adequacy and keeping only changes that
leave the set adequate.

Ghassabani et al. presented also an algorithm for finding all MIVCs, called \texttt{All\_IVCs}, which is based on the monotonicity property and the shrinking procedure. To obtain each single MIVC, their algorithm first find a maximal unexplored subset, checks it for adequacy and if it is adequate, it is shrunk to an MIVC (using the agorithm \texttt{IVC\_BF}). During the whole computation, the set of unexplored subsets is appropriately maintained. This algorithm computes MIVCs in an online manner, however, authors of the algorithm found out that it is rather inefficient since the computation of the shrinking procedure is very expensive. Therefore, they proposed to use an algorithm~\cite{single-ivc}, called IVC\_UC, for finding an approximately minimal IVC instead of using the shrinking procedure which returns guaranteed MIVCs. Such algorithm does not output MIVCs in an online manner. Instead, it identify MIVCs at the end of the computation when adequacy of all subsets is determined. Their experimental evaluation shown, that IVC\_UC is much faster than IVC\_BF. However, it lacks the ability of online enumeration and it is not applicable in cases, where the complete enumeration is not possible due to the large size of a search space. 

\todo{Pseudocode of \texttt{All\_IVCs}}


\begin{algorithm}[!t]
\input{./algs/all_ivcs}
\caption{All\_IVCs: Algorithm for MIVC enumeration by Ghassabani et al. }
\end{algorithm}


